---
title: 位运算实现字母的大小写转换
tags: [目录,note,字符,位操作]
copyright: true
toc: true
date: 2022-01-01 14:54:58
---

### 编码

在计算机中，任何东西都是二进制数据，那么，我们在屏幕上看见的字符是怎么被识别的呢？

这要依托于一套特定的编码，将二进制数据映射成字符

ascll编码是目前应用比较广泛的，所以这里我们讨论的大小写转换基于ascll编码体系（事实上后面大多数编码都是兼容ascll编码的）

<!--more-->



### ASCLL编码

**ASCII 码表**

<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td><p><strong>ASCII 值</strong></p></td><td><p><strong>控制字符</strong></p></td><td><p><strong>ASCII 值</strong></p></td><td><p><strong>控制字符</strong></p></td><td><p><strong>ASCII 值</strong></p></td><td><p><strong>控制字符</strong></p></td><td><p><strong>ASCII 值</strong></p></td><td><p><strong>控制字符</strong></p></td></tr><tr><td><p>0</p></td><td><p>NUL</p></td><td><p>32</p></td><td><p>(space)</p></td><td><p>64</p></td><td><p>@</p></td><td><p>96</p></td><td><p>、</p></td></tr><tr><td><p>1</p></td><td><p>SOH</p></td><td><p>33</p></td><td><p>！</p></td><td><p>65</p></td><td><p>A</p></td><td><p>97</p></td><td><p>a</p></td></tr><tr><td><p>2</p></td><td><p>STX</p></td><td><p>34</p></td><td><p>”</p></td><td><p>66</p></td><td><p>B</p></td><td><p>98</p></td><td><p>b</p></td></tr><tr><td><p>3</p></td><td><p>ETX</p></td><td><p>35</p></td><td><p>#</p></td><td><p>67</p></td><td><p>C</p></td><td><p>99</p></td><td><p>c</p></td></tr><tr><td><p>4</p></td><td><p>EOT</p></td><td><p>36</p></td><td><p>$</p></td><td><p>68</p></td><td><p>D</p></td><td><p>100</p></td><td><p>d</p></td></tr><tr><td><p>5</p></td><td><p>ENQ</p></td><td><p>37</p></td><td><p>%</p></td><td><p>69</p></td><td><p>E</p></td><td><p>101</p></td><td><p>e</p></td></tr><tr><td><p>6</p></td><td><p>ACK</p></td><td><p>38</p></td><td><p>&amp;</p></td><td><p>70</p></td><td><p>F</p></td><td><p>102</p></td><td><p>f</p></td></tr><tr><td><p>7</p></td><td><p>BEL</p></td><td><p>39</p></td><td><p>'</p></td><td><p>71</p></td><td><p>G</p></td><td><p>103</p></td><td><p>g</p></td></tr><tr><td><p>8</p></td><td><p>BS</p></td><td><p>40</p></td><td><p>(</p></td><td><p>72</p></td><td><p>H</p></td><td><p>104</p></td><td><p>h</p></td></tr><tr><td><p>9</p></td><td><p>HT</p></td><td><p>41</p></td><td><p>)</p></td><td><p>73</p></td><td><p>I</p></td><td><p>105</p></td><td><p>i</p></td></tr><tr><td><p>10</p></td><td><p>LF</p></td><td><p>42</p></td><td><p>*</p></td><td><p>74</p></td><td><p>J</p></td><td><p>106</p></td><td><p>j</p></td></tr><tr><td><p>11</p></td><td><p>VT</p></td><td><p>43</p></td><td><p>+</p></td><td><p>75</p></td><td><p>K</p></td><td><p>107</p></td><td><p>k</p></td></tr><tr><td><p>12</p></td><td><p>FF</p></td><td><p>44</p></td><td><p>,</p></td><td><p>76</p></td><td><p>L</p></td><td><p>108</p></td><td><p>l</p></td></tr><tr><td><p>13</p></td><td><p>CR</p></td><td><p>45</p></td><td><p>-</p></td><td><p>77</p></td><td><p>M</p></td><td><p>109</p></td><td><p>m</p></td></tr><tr><td><p>14</p></td><td><p>SO</p></td><td><p>46</p></td><td><p>.</p></td><td><p>78</p></td><td><p>N</p></td><td><p>110</p></td><td><p>n</p></td></tr><tr><td><p>15</p></td><td><p>SI</p></td><td><p>47</p></td><td><p>/</p></td><td><p>79</p></td><td><p>O</p></td><td><p>111</p></td><td><p>o</p></td></tr><tr><td><p>16</p></td><td><p>DLE</p></td><td><p>48</p></td><td><p>0</p></td><td><p>80</p></td><td><p>P</p></td><td><p>112</p></td><td><p>p</p></td></tr><tr><td><p>17</p></td><td><p>DCI</p></td><td><p>49</p></td><td><p>1</p></td><td><p>81</p></td><td><p>Q</p></td><td><p>113</p></td><td><p>q</p></td></tr><tr><td><p>18</p></td><td><p>DC2</p></td><td><p>50</p></td><td><p>2</p></td><td><p>82</p></td><td><p>R</p></td><td><p>114</p></td><td><p>r</p></td></tr><tr><td><p>19</p></td><td><p>DC3</p></td><td><p>51</p></td><td><p>3</p></td><td><p>83</p></td><td><p>S</p></td><td><p>115</p></td><td><p>s</p></td></tr><tr><td><p>20</p></td><td><p>DC4</p></td><td><p>52</p></td><td><p>4</p></td><td><p>84</p></td><td><p>T</p></td><td><p>116</p></td><td><p>t</p></td></tr><tr><td><p>21</p></td><td><p>NAK</p></td><td><p>53</p></td><td><p>5</p></td><td><p>85</p></td><td><p>U</p></td><td><p>117</p></td><td><p>u</p></td></tr><tr><td><p>22</p></td><td><p>SYN</p></td><td><p>54</p></td><td><p>6</p></td><td><p>86</p></td><td><p>V</p></td><td><p>118</p></td><td><p>v</p></td></tr><tr><td><p>23</p></td><td><p>TB</p></td><td><p>55</p></td><td><p>7</p></td><td><p>87</p></td><td><p>W</p></td><td><p>119</p></td><td><p>w</p></td></tr><tr><td><p>24</p></td><td><p>CAN</p></td><td><p>56</p></td><td><p>8</p></td><td><p>88</p></td><td><p>X</p></td><td><p>120</p></td><td><p>x</p></td></tr><tr><td><p>25</p></td><td><p>EM</p></td><td><p>57</p></td><td><p>9</p></td><td><p>89</p></td><td><p>Y</p></td><td><p>121</p></td><td><p>y</p></td></tr><tr><td><p>26</p></td><td><p>SUB</p></td><td><p>58</p></td><td><p>:</p></td><td><p>90</p></td><td><p>Z</p></td><td><p>122</p></td><td><p>z</p></td></tr><tr><td><p>27</p></td><td><p>ESC</p></td><td><p>59</p></td><td><p>;</p></td><td><p>91</p></td><td><p>[</p></td><td><p>123</p></td><td><p>{undefined</p></td></tr><tr><td><p>28</p></td><td><p>FS</p></td><td><p>60</p></td><td><p>&lt;&nbsp;</p></td><td><p>92</p></td><td><p>\</p></td><td><p>124</p></td><td><p>|</p></td></tr><tr><td><p>29</p></td><td><p>GS</p></td><td><p>61</p></td><td><p>=</p></td><td><p>93</p></td><td><p>]</p></td><td><p>125</p></td><td><p>}</p></td></tr><tr><td><p>30</p></td><td><p>RS</p></td><td><p>62</p></td><td><p>&gt;&nbsp;</p></td><td><p>94</p></td><td><p>^</p></td><td><p>126</p></td><td><p>~</p></td></tr><tr><td><p>31</p></td><td><p>US</p></td><td><p>63</p></td><td><p>?</p></td><td><p>95</p></td><td><p>—</p></td><td><p>127</p></td><td><p>DEL</p></td></tr></tbody></table>
（此表转载自[ jiayoudangdang 的博客 - CSDN 博客 ](https://blog.csdn.net/jiayoudangdang/article/details/79828853)）



### 字母编码之间的关系



#### 十进制关系

看到上面的编码表之后，发现a-z与A-Z之间分别是连续的，编码值是递增的

所以实际上会存在这种关系：

```c
'a'+1 == 'b'
'z'-'a' == 25
//大写也是一样的
```

嗯，这很容易就能看出来



然后比较大小写字母

我们很容易就会以为，大写字母的值会要比小写字母的值大，其实并不是，从上表就可以看出

'A' = 65  a='97'

很明显，大写字母的值要小于小写字母的值，而且上面提到过，大小写字母的编码值是连续的，且排序在后面要大于排序在前面的

所以：

> 每个大写字母总是比相对应的小写字母要小‘a’ - ‘A’的值，也就是32





自然，我们在转换的时候就可以通过加减32来实现大小写转换

```c
char a = 'a';
char A = 'a' - 32;
printf("%c\n",A);
```

```powershell
➜ cpp  .\a.exe
A
```

或者说加减('a'-'A') 

```c
char g = 'g';
g -= 'a' - 'A';
printf("%c\n",g);
```

```powershell
➜ cpp  .\a.exe
G
```

tip:'b' - 'B' 'c' - 'c' 之类的也是可以的，就不再细说举例了



当然，这么做还有个缺点，我们不能盲目地加减，我们必须还要判断其为大写还是小写，因为大写减去32将不再是字母，同理，小写加上32也不再是字母



#### 二进制关系

那么大小写字母为什么不编码在连续的位置的呢，谁知道呢，我只知道这么编码可以为我们进行大小写转换提供捷径，你不信？来看看

我们来列举几个大小写的二进制值看看（你可以对照上面的表自己算一下，或者用win系统自带计算器的程序员模式）

| 字母 | 十进制 |  二进制  |
| :--: | :----: | :------: |
|  A   |   65   | 01000001 |
|  a   |   97   | 01100001 |
|  B   |   66   | 01000010 |
|  b   |   98   | 01100010 |
|  Z   |   90   | 01011010 |
|  z   |  122   | 01111010 |

眼睛尖一点，你会发现对应的大小写字母，只是从左向右看第3位不同，其他位完全相同。大写字母这一位是0，小写字母这一位是1，而这一位正好是第6位，所以大小写之间差了32（$2^5=32$）

这有用吗？非常有用！他们只有一位不同，我们完全可以利用位运算符来对这一位进行操作来达到大小写转换的目的

##### &，|

先提一下&,|的小性质

> 每一位&1,结果不变，&0则为0
>
> 每一位|0,结果不变，|1则为1

##### 小写转大写

对于小写字母，我们可以用”&”将第5位变成0:

```c
char a = 'a';
a &= 0xDF;//0xDF是11011111B的十六进制表示
printf("a = %c",a);
```

```powershell
➜ cpp  .\a.exe
a = A
```

##### 大写转小写

对于大写字母，我们可以用"|"将第5位变成1

```c
 char A = 'A';
A |= 0x20; //0x20是00100000的十六进制表示
printf("A = %c",A);
```

```powershell
➜ cpp  .\a.exe
A = a
```



这么做很快捷，简单，相比于上面的方法还不用判断大小写，为什么这么说？

一个字符转大写的时候，就算它本身已经是大写了，它的第5位是0,0&0会怎么样，还不是0，等于说没有变

小写类似，1|1也是1，并没有改变



##### 大小写互转

那如果要大小写互转呢？那就使用异或操作符^

> ^执行半加操作，怎么理解？就是在那一位执行加法，但是不进位。
>
> 也就是说，0^0=0,0^1=1,1^0=1,1^1=0
>
> 再直白一点，^0就是不变，^1就是取反

只要在那一位^1,就能实现将0变为1,1变为0，从而实现大小写转换

```c
char A = 'A';
A ^= 0x20; //0x20是00100000的十六进制表示
char a = 'a';
a ^= 0x20;
printf("A = %c,a = %c\n",A,a);
```

```powershell
➜ cpp  .\a.exe
A = a,a = A
```



### 应用



可以用宏定义封装一下（不封装也行，只是可读性会变差），进行快速转换，可以简化代码结构，提高效率

```c
#include <stdio.h>

#define UPPER(x) (x&0xDF)
#define LOWER(x) (x|0x20)
#define toLOWER(x) (x|=0x20)   //0010 0000B
#define toUPPER(x) (x&=0xDF)
#define Trans(x) (x^=0x20)
#define TransTo(x) (x^0x20)

int main(void)
{
        char a = 'a',b = 'b',A = 'A',B = 'B';
        toLOWER(A);
        toUPPER(a);
        Trans(b);
        printf("A = %c,a = %c,b = %c ",A,a,b);
        return 0;
}
```



```powershell
➜ cpp  .\a.exe
A = a,a = A,b = B
```

